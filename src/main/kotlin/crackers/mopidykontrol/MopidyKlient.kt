/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package crackers.mopidykontrol

import org.slf4j.LoggerFactory
import java.io.IOException
import java.net.ConnectException
import java.net.URI
import java.net.http.HttpClient
import java.net.http.WebSocket
import java.time.Duration
import java.util.concurrent.*
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock
import kotlin.math.max
import kotlin.math.min

/**
 * A client for the Mopidy websocket API.
 *
 * TODO add a way to register event handlers
 * @param host the host to connect to
 * @param port the port to connect to
 * @param timeout the timeout for the connection
 * @param reconnect whether to reconnect if the connection is lost
 */
class MopidyKlient(
    host: String,
    port: Int = 6680,
    private val timeout: Duration = Duration.ofSeconds(5),
    private val reconnect: Boolean = true
) : AutoCloseable {

    private val logger = LoggerFactory.getLogger(MopidyKlient::class.java.simpleName)

    private val server = "ws://$host:$port/mopidy/ws"

    enum class PlayerState {
        PLAYING, PAUSED, STOPPED
    }

    // convenience stuff for the JSON-RPC API
    private val idCounter = AtomicInteger(0)
    private val nextId: Int
        get() = idCounter.incrementAndGet()

    // response management
    private val errorResponse = RPCResponse(id = -1)
    private val responseMapper = ConcurrentHashMap<Int, SynchronousQueue<RPCResponse>>()

    // connection management
    private val connecting = AtomicBoolean(false)
    private val closing = AtomicBoolean(false)
    private val scheduler = Executors.newSingleThreadScheduledExecutor()
    private fun doConnect() {
        if (reconnect && !closing.get() && connecting.compareAndSet(false, true)) {
            scheduler.schedule(::connect, timeout.toMillis(), TimeUnit.MILLISECONDS)
        }
    }

    /**
     * The listener for the websocket. This is where the responses are parsed and the response queues are managed.
     */
    private val socketListener = object : WebSocket.Listener {
        // ostensibly got a response
        override fun onText(webSocket: WebSocket?, data: CharSequence?, last: Boolean): CompletionStage<*>? {
            val response = try {
                when {
                    // nothing received, which is kinda weird
                    data == null -> {
                        logger.error("Received null data")
                        errorResponse
                    }
                    // event handling
                    data.contains("\"event\":") -> {
                        eventHandler(data.toString())
                        null
                    }
                    // response handling
                    else -> RPCResponse.fromJson(data.toString())
                }
            } catch (e: Exception) {
                logger.error("Cannot parse response:\n$data", e)
                errorResponse
            }
            if (response != null) responseMapper[response.id]?.put(response)
            return super.onText(webSocket, data, last)
        }

        // websocket closed
        override fun onError(webSocket: WebSocket?, error: Throwable?) {
            logger.error("Error on websocket", error)
            // TODO should we do this all the time?????
            if (reconnect && error is ConnectException) doConnect()
            super.onError(webSocket, error)
        }
    }

    private val lock = ReentrantLock()

    private var wsClient: WebSocket? = null

    private fun connect() {
        if (closing.get()) return // prevent re-opening when close was explicitly called

        logger.warn("Connecting to mopidy at $server")
        connecting.set(false)
        HttpClient.newHttpClient().newWebSocketBuilder()
            .connectTimeout(timeout)
            .buildAsync(URI(server), socketListener).whenComplete { client, error ->
                if (error != null) {
                    logger.error("Cannot connect to mopidy: {}", error.localizedMessage)
                    wsClient = null
                    doConnect()
                } else {
                    wsClient = client
                    logger.info("Connected to mopidy")
                }
            }.get()
    }

    init {
        connect()
    }

    /**
     * The handler for events. By default, this just logs the event.
     *
     * TODO provide a real event object
     * TODO provide a way to register event handlers?
     */
    val eventHandler: (String) -> Unit = { logger.info(it) }

    override fun close() {
        closing.set(true)
        lock.withLock {
            wsClient?.sendClose(WebSocket.NORMAL_CLOSURE, "Close")?.thenRun {
                logger.info("Closed")
            }?.exceptionally {
                if (it !is IOException) logger.error("Close: $it")
                null
            }
        }
    }

    fun play(args: String? = null) {
        sendRequest(RPCRequest(id = nextId, command = Command.PlaybackPlay))
    }

    fun resume() {
        sendRequest(RPCRequest(id = nextId, command = Command.PlaybackResume))
    }

    fun pause() {
        sendRequest(RPCRequest(id = nextId, command = Command.PlaybackPause))
    }

    fun stop() {
        sendRequest(RPCRequest(id = nextId, command = Command.PlaybackStop))
    }

    fun next() {
        sendRequest(RPCRequest(id = nextId, command = Command.PlaybackNext))
    }

    fun previous() {
        sendRequest(RPCRequest(id = nextId, command = Command.PlaybackPrevious))
    }

    var volume: Int
        get() {
            // set up the request, then use the ID to set up a response queue and wait for it
            val response = sendRequestWithResponse(RPCRequest(id = nextId, command = Command.MixerGetVolume))
            return response.result?.toInt() ?: -1
        }
        set(value) {
            sendRequest(RPCRequest(id = nextId, command = Command.MixerSetVolume, params = mapOf("volume" to value)))
        }

    fun volumeUp() {
        val current = volume
        if (volume < 100) volume = min(current + 5, 100)
    }

    fun volumeDown() {
        val current = volume
        if (volume > 0) volume = max(current - 5, 0)
    }

    var mute: Boolean
        get() {
            logger.debug("Getting mute")
            return false
        }
        set(value) {
            logger.debug("Setting mute to $value")
        }
    var state: PlayerState
        get() {
            logger.debug("Getting state")
            return PlayerState.STOPPED
        }
        set(value) {
            logger.debug("Setting state to $value")
        }

    private fun sendRequest(request: RPCRequest) = lock.withLock {
        if (closing.get()) return@withLock

        logger.debug("Sending command: ${request.method}")
        wsClient?.run {
            if (isInputClosed) {
                sendText(request.toJson(), true).exceptionally {
                    logger.error("Error on send", it)
                    null
                }
            }
        } ?: doConnect()
    }

    private fun sendRequestWithResponse(request: RPCRequest): RPCResponse = lock.withLock {
        val responseQueue = SynchronousQueue<RPCResponse>()
        responseMapper[request.id] = responseQueue
        sendRequest(request)
        return responseQueue.poll(timeout.toMillis(), TimeUnit.MILLISECONDS) ?: errorResponse
    }
}
